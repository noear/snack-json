/*
 * Copyright 2005-2025 noear.org and authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.noear.snack4.json;

import org.noear.snack4.Feature;
import org.noear.snack4.ONode;
import org.noear.snack4.Options;
import org.noear.snack4.json.util.IoUtil;

import java.io.IOException;
import java.io.Reader;
import java.io.StringReader;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.util.*;

/**
 * Json ËØªÂèñÂô®
 *
 * @author noear noear 2025/3/16 created
 * @since 4.0
 * */
public class JsonReader {
    public static ONode read(String json) throws IOException {
        return read(json, null);
    }

    public static ONode read(String json, Options opts) throws IOException {
        return new JsonReader(new StringReader(json), opts).read();
    }

    public static ONode read(Reader reader) throws IOException {
        return new JsonReader(reader, null).read();
    }

    public static ONode read(Reader reader, Options opts) throws IOException {
        return new JsonReader(reader, opts).read();
    }

    /// ///////////////

    private final Options opts;
    private final ParserState state;

    private final StringBuilder stringBuilder;

    private final boolean Read_AllowComment;
    private final boolean Read_DisableUnquotedKeys;
    private final boolean Read_DisableSingleQuotes;
    private final boolean Read_UnwrapJsonString;
    private final boolean Read_ConvertSnakeToCamel;

    private StringBuilder getStringBuilder() {
        stringBuilder.setLength(0);
        return stringBuilder;
    }

    public JsonReader(Reader reader) {
        this(reader, null);
    }

    public JsonReader(Reader reader, Options opts) {
        Objects.requireNonNull(reader, "reader");

        this.state = new ParserState(reader);
        this.opts = opts == null ? Options.DEF_OPTIONS : opts;

        this.stringBuilder = new StringBuilder(32);

        this.Read_AllowComment = this.opts.hasFeature(Feature.Read_AllowComment);
        this.Read_DisableUnquotedKeys = this.opts.hasFeature(Feature.Read_DisableUnquotedKeys);
        this.Read_DisableSingleQuotes = this.opts.hasFeature(Feature.Read_DisableSingleQuotes);
        this.Read_UnwrapJsonString = this.opts.hasFeature(Feature.Read_UnwrapJsonString);
        this.Read_ConvertSnakeToCamel = this.opts.hasFeature(Feature.Read_ConvertSnakeToCamel);
    }

    public ONode read() throws IOException {
        try {
            state.fillBuffer();
            ONode node = parseValue();
            state.skipWhitespace();

            if (Read_AllowComment) {
                state.skipComments();
            }

            if (state.bufferPosition < state.bufferLimit) {
                throw state.error("Unexpected data after json root");
            }
            return node;
        } finally {
            state.reader.close();
        }
    }

    private ONode parseValue() throws IOException {
        state.skipWhitespace();

        if (Read_AllowComment) {
            state.skipComments();
        }

        char c = state.peekChar();

        if (c == '{') return parseObject();
        if (c == '[') return parseArray();
        if (c == '"' || (Read_DisableSingleQuotes == false && c == '\'')) {
            String str = parseString();

            if (Read_UnwrapJsonString) {
                if (str.length() > 1) {
                    char c1 = str.charAt(0);
                    char c2 = str.charAt(str.length() - 1);
                    if ((c1 == '{' && c2 == '}') || (c1 == '[' && c2 == ']')) {
                        return ONode.ofJson(str, opts);
                    }
                }
            }

            return new ONode(opts, str);
        }
        // Êñ∞Â¢ûÁöÑ JavaScript Date ÂØπË±°ÊîØÊåÅ
        if (c == 'n' && state.peekChar(1) == 'e' && state.peekChar(2) == 'w') {
            return parseDate();
        }

        if (c == '-' || (c >= '0' && c <= '9')) return new ONode(opts, parseNumber());
        if (c == 't') return parseKeyword("true", true);
        if (c == 'f') return parseKeyword("false", false);
        if (c == 'n') return parseKeyword("null", null);
        if (c == 'N') return parseKeyword("NaN", null);
        if (c == 'u') return parseKeyword("undefined", null);
        throw state.error("Unexpected character: " + c);
    }

    /**
     * Ëß£Êûê JavaScript Date ÂØπË±°: new Date(long)
     *
     * @return ONode (Date)
     * @throws IOException
     */
    private ONode parseDate() throws IOException {
        // ÊúüÊúõ "new Date("
        state.expect('n');
        state.expect('e');
        state.expect('w');
        state.skipWhitespace(); // ÂÖÅËÆ∏ 'new' ÂêéÊúâÁ©∫Ê†º
        state.expect('D');
        state.expect('a');
        state.expect('t');
        state.expect('e');
        state.expect('(');
        state.skipWhitespace();

        // üåü ‰ºòÂåñÁÇπÔºö‰ΩøÁî® parseNumber() Ëß£ÊûêÊó∂Èó¥Êà≥
        Number number = parseNumber();

        // Á°Æ‰øùÊï∞Â≠óÊòØ Long Á±ªÂûãÊàñÂèØ‰ª•ÂÆâÂÖ®ËΩ¨Êç¢‰∏∫ Long
        long timestamp;
        if (number instanceof Long) {
            timestamp = (Long) number;
        } else {
            // Â¶ÇÊûúÊòØ Double/BigDecimalÔºåÂèØËÉΩ‰∏¢Â§±Á≤æÂ∫¶Ôºå‰ΩÜÊ≠§Â§ÑÈúÄÂÅöÂá∫ÂÜ≥ÂÆö
            timestamp = number.longValue();
        }

        state.skipWhitespace();
        state.expect(')'); // ÊúüÊúõ ')'

        return new ONode(opts, new Date(timestamp));
    }

    private ONode parseObject() throws IOException {
        Map<String, ONode> map = new LinkedHashMap<>(16);
        state.expect('{');
        while (true) {
            state.skipWhitespace();
            if (state.peekChar() == '}') {
                state.bufferPosition++;
                break;
            }

            String key = parseKey();

            if (key.isEmpty() && opts.hasFeature(Feature.Read_AllowEmptyKeys) == false) {
                throw new JsonParseException("Empty key is not allowed");
            }

            state.skipWhitespace();
            state.expect(':');
            ONode value = parseValue();
            map.put(key, value);

            state.skipWhitespace();
            if (state.peekChar() == ',') {
                state.bufferPosition++;
                state.skipWhitespace();
                if (state.peekChar() == '}') throw state.error("Trailing comma in object");
            } else if (state.peekChar() == '}') {
                // Continue to closing
            } else {
                throw state.error("Expected ',' or '}'");
            }
        }
        return new ONode(opts, map);
    }

    private String parseKey() throws IOException {
        String key;
        if (Read_DisableUnquotedKeys == false) {
            char c = state.peekChar();
            if (c != '"' && c != '\'') {
                key = parseUnquotedString();
            } else {
                key = parseString();
            }
        } else {
            key = parseString();
        }

        // Â¶ÇÊûúÂêØÁî®‰∫ÜËõáÂΩ¢ËΩ¨È©ºÂ≥∞ÁâπÊÄßÔºåÂàôËøõË°åËΩ¨Êç¢
        if (Read_ConvertSnakeToCamel) {
            key = convertSnakeToCamel(key);
        }
        return key;
    }

    private String convertSnakeToCamel(String snakeCase) {
        if (snakeCase == null || snakeCase.isEmpty()) {
            return snakeCase;
        }

        StringBuilder result = getStringBuilder();
        boolean toUpperCase = false;
        boolean firstChar = true;

        for (int i = 0; i < snakeCase.length(); i++) {
            char c = snakeCase.charAt(i);

            if (c == '_') {
                // ‰∏ãÂàíÁ∫øÊ†áËÆ∞‰∏ã‰∏Ä‰∏™Â≠óÁ¨¶ÈúÄË¶ÅÂ§ßÂÜô
                toUpperCase = true;
            } else {
                if (toUpperCase) {
                    result.append(Character.toUpperCase(c));
                    toUpperCase = false;
                } else {
                    // Á¨¨‰∏Ä‰∏™Â≠óÁ¨¶‰øùÊåÅÂ∞èÂÜôÔºåÂÖ∂‰ªñÂ≠óÁ¨¶‰øùÊåÅÂéüÊ†∑
                    if (firstChar) {
                        result.append(Character.toLowerCase(c));
                    } else {
                        result.append(c);
                    }
                }
                firstChar = false;
            }
        }

        return result.toString();
    }

    private String parseUnquotedString() throws IOException {
        StringBuilder sb = getStringBuilder();
        while (true) {
            char c = state.peekChar();
            if (c == ':' || c == ',' || c == '}' || c == ']' || Character.isWhitespace(c)) {
                break;
            }
            sb.append(state.nextChar());
        }
        return sb.toString();
    }

    private ONode parseArray() throws IOException {
        List<ONode> list = new ArrayList<>(10);
        state.expect('[');
        while (true) {
            state.skipWhitespace();
            if (state.peekChar() == ']') {
                state.bufferPosition++;
                break;
            }

            list.add(parseValue());

            state.skipWhitespace();
            if (state.peekChar() == ',') {
                state.bufferPosition++;
                state.skipWhitespace();
                if (state.peekChar() == ']') throw state.error("Trailing comma in array");
            } else if (state.peekChar() == ']') {
                // Continue to closing
            } else {
                throw state.error("Expected ',' or ']'");
            }
        }
        return new ONode(opts, list);
    }

    private String parseString() throws IOException {
        char quoteChar = state.nextChar();
        if (quoteChar != '"' && !(Read_DisableSingleQuotes == false && quoteChar == '\'')) {
            throw state.error("Expected string to start with a quote");
        }

        StringBuilder sb = getStringBuilder();

        // ÊÄßËÉΩ‰ºòÂåñÔºöÂú®ÁºìÂÜ≤Âå∫ÂÜÖËøõË°åÊâπÈáèÂ§çÂà∂ÔºåÂáèÂ∞ë nextChar() ÂíåÂçïÂ≠óÁ¨¶ append() ÁöÑË∞ÉÁî®
        while (true) {
            // Á°Æ‰øùÁºìÂÜ≤Âå∫ÊúâÂÜÖÂÆπ
            if (state.bufferPosition >= state.bufferLimit) {
                if (!state.fillBuffer()) {
                    throw state.error("Unclosed string");
                }
            }

            int start = state.bufferPosition;
            int end = start;

            // Âú®ÂΩìÂâçÁºìÂÜ≤Âå∫ÂÜÖÂø´ÈÄüÊâ´ÊèèÔºåÁõ¥Âà∞ÈÅáÂà∞Ôºö
            // 1. ÁªìÊùüÂºïÂè∑ (quoteChar)
            // 2. ËΩ¨‰πâÂ≠óÁ¨¶ (\)
            // 3. ÊéßÂà∂Â≠óÁ¨¶ (c < 0x20)
            while (end < state.bufferLimit) {
                char c = state.buffer[end];
                if (c == quoteChar || c == '\\' || c < 32) { //0x20
                    break;
                }
                end++;
            }

            // 1. ÊâπÈáèÊ∑ªÂä†Â≠óÁ¨¶Âà∞ StringBuilder
            if (end > start) {
                // ‰ΩøÁî® StringBuilder ÁöÑÊâπÈáèËøΩÂä†ÊñπÊ≥ïÔºåÊÄßËÉΩÊõ¥È´ò
                sb.append(state.buffer, start, end - start);
            }

            // 2. Êõ¥Êñ∞‰ΩçÁΩÆ
            state.bufferPosition = end;

            // 3. Â§ÑÁêÜÁªàÊ≠¢Êù°‰ª∂
            if (state.bufferPosition == state.bufferLimit) {
                // Â¶ÇÊûúÊòØÂõ†‰∏∫ buffer ËÄóÂ∞ΩËÄåÈÄÄÂá∫ÔºåÁªßÁª≠‰∏ã‰∏ÄËΩÆ fillBuffer()
                continue;
            }

            // 4. Â§ÑÁêÜÁâπÊÆäÂ≠óÁ¨¶ (ÂøÖÈ°ª‰ΩøÁî® nextChar() Êù•Ê≠£Á°ÆÊ∂àËÄóÂíåÊõ¥Êñ∞‰ΩçÁΩÆ)
            char c = state.nextChar();

            if (c == quoteChar) {
                break; // ÈÅáÂà∞ÁªìÊùüÂºïÂè∑ÔºåËß£ÊûêÂÆåÊàê
            }

            if (c == '\\') {
                // Â§ÑÁêÜËΩ¨‰πâÂ≠óÁ¨¶
                c = state.nextChar();
                switch (c) {
                    case '"':
                    case '\'':
                    case '\\':
                        sb.append(c);
                        break;
                    case '/':
                        sb.append('/');
                        break;
                    case 'b':
                        sb.append('\b');
                        break;
                    case 'f':
                        sb.append('\f');
                        break;
                    case 'n':
                        sb.append('\n');
                        break;
                    case 'r':
                        sb.append('\r');
                        break;
                    case 't':
                        sb.append('\t');
                        break;
                    case 'u': {
                        int val = 0;
                        for (int i = 0; i < 4; i++) {
                            char hex_char = state.nextChar();
                            val <<= 4; // val = val * 16
                            if (hex_char >= '0' && hex_char <= '9') {
                                val += hex_char - '0';
                            } else if (hex_char >= 'a' && hex_char <= 'f') {
                                val += hex_char - 'a' + 10;
                            } else if (hex_char >= 'A' && hex_char <= 'F') {
                                val += hex_char - 'A' + 10;
                            } else {
                                throw state.error("Invalid Unicode escape");
                            }
                        }
                        sb.append((char) val);
                        break;
                    }
                    default: {
                        // ÂÖºÂÆπÊóßÁöÑÂÖ´ËøõÂà∂ËΩ¨‰πâÔºàËôΩÁÑ∂ JSON ‰∏çÊîØÊåÅÔºâ
                        if (c >= '0' && c <= '7') {
                            // ÂÅáËÆæ IoUtil.CHARS_MARK_REV Â≠òÂú®Âπ∂ËÉΩÊ≠£Á°ÆÊò†Â∞Ñ
                            sb.append(IoUtil.CHARS_MARK_REV[(int) c]);
                        } else if (opts.hasFeature(Feature.Read_AllowInvalidEscapeCharacter)) {
                            sb.append(c); // ÂøΩÁï•ËΩ¨‰πâÔºåÁõ¥Êé•ËøΩÂä†Â≠óÁ¨¶
                        } else if (opts.hasFeature(Feature.Read_AllowBackslashEscapingAnyCharacter)) {
                            // ÂÖÅËÆ∏ \X ÂΩ¢ÂºèÁöÑ‰ªªÊÑèËΩ¨‰πâÔºåËøΩÂä† \ Âíå X
                            sb.append('\\').append(c);
                        } else {
                            // ‰∏•Ê†ºÊ®°Âºè (RFC 8259)
                            throw state.error("Invalid escape character: \\" + c);
                        }
                    }
                }
            } else if (c < 32) { //0x20
                // Â§ÑÁêÜÊú™ËΩ¨‰πâÁöÑÊéßÂà∂Â≠óÁ¨¶
                if (opts.hasFeature(Feature.Read_AllowUnescapedControlCharacters) == false) {
                    // ‰∏•Ê†ºÊ®°Âºè
                    throw state.error("Unescaped control character: 0x" + Integer.toHexString(c));
                }
                sb.append(c); // ÂÆΩÊùæÊ®°Âºè‰∏ãËøΩÂä†
            } else {
                // ÁêÜËÆ∫‰∏äÔºåÂú®ÂùóÂ§çÂà∂ÈÄªËæë‰∏≠ÔºåÊôÆÈÄöÂ≠óÁ¨¶Â∑≤ÁªèË¢´Â§ÑÁêÜ‰∫ÜÔºå
                // Èô§Èùû nextChar() ÊÑèÂ§ñËØªÂèñ‰∫Ü‰∏Ä‰∏™ÊôÆÈÄöÂ≠óÁ¨¶Ôºå‰ΩÜ‰∏∫‰∫ÜÂÆâÂÖ®‰øùÁïô„ÄÇ
                sb.append(c);
            }
        }

        return sb.toString();
    }

    private Number parseNumber() throws IOException {
        StringBuilder sb = getStringBuilder();
        char c = state.peekChar();

        // Â§ÑÁêÜË¥üÊï∞
        if (c == '-') {
            sb.append(state.nextChar());
        }

        // Ëß£ÊûêÊï¥Êï∞ÈÉ®ÂàÜ
        if (opts.hasFeature(Feature.Read_AllowZeroLeadingNumbers) == false) {
            if (state.peekChar() == '0') {
                sb.append(state.nextChar());
                if (isDigit(state.peekChar())) {
                    throw state.error("Leading zeros not allowed");
                }
            }
        }

        if (isDigit(state.peekChar())) {
            while (isDigit(state.peekChar())) {
                sb.append(state.nextChar());
            }
        } else if (sb.length() == 0) {
            throw state.error("Invalid number format");
        }

        // Ëß£ÊûêÂ∞èÊï∞ÈÉ®ÂàÜ
        if (state.peekChar() == '.') {
            sb.append(state.nextChar());
            if (!isDigit(state.peekChar())) {
                throw state.error("Invalid decimal format");
            }
            while (isDigit(state.peekChar())) {
                sb.append(state.nextChar());
            }
        }

        // Ëß£ÊûêÊåáÊï∞ÈÉ®ÂàÜ
        if (state.peekChar() == 'e' || state.peekChar() == 'E') {
            sb.append(state.nextChar());
            if (state.peekChar() == '+' || state.peekChar() == '-') {
                sb.append(state.nextChar());
            }
            if (!isDigit(state.peekChar())) {
                throw state.error("Invalid exponent format");
            }
            while (isDigit(state.peekChar())) {
                sb.append(state.nextChar());
            }
        }

        // Ê£ÄÊü•Á±ªÂûãÂêéÁºÄ (L, F, D, M) - ‰ΩÜ‰∏çÊ∑ªÂä†Âà∞Â≠óÁ¨¶‰∏≤‰∏≠
        char postfix = 0;
        if (state.peekChar() == 'L' || state.peekChar() == 'F' || state.peekChar() == 'D' || state.peekChar() == 'M') {
            postfix = state.nextChar(); // ËØªÂèñÂêéÁºÄ‰ΩÜ‰∏çÊ∑ªÂä†Âà∞sb‰∏≠
        }

        String numStr = sb.toString();
        try {
            // Ê†πÊçÆÂêéÁºÄÁ±ªÂûãËß£ÊûêÊï∞Â≠ó
            if (postfix == 'D') {
                return Double.parseDouble(numStr);
            } else if (postfix == 'F') {
                return Float.parseFloat(numStr);
            } else if (postfix == 'L') {
                return Long.parseLong(numStr);
            } else {
                if (numStr.indexOf('.') >= 0 || numStr.indexOf('e') >= 0 || numStr.indexOf('E') >= 0) {
                    if (numStr.length() > 19 || opts.hasFeature(Feature.Read_UseBigDecimalMode)) {
                        return new BigDecimal(numStr);
                    } else {
                        return Double.parseDouble(numStr);
                    }
                } else {
                    if (numStr.length() > 19 || opts.hasFeature(Feature.Read_UseBigIntegerMode)) {
                        return new BigInteger(numStr);
                    } else {
                        long longVal = Long.parseLong(numStr);
                        if (longVal <= Integer.MAX_VALUE && longVal >= Integer.MIN_VALUE) {
                            return (int) longVal;
                        }
                        return longVal;
                    }
                }
            }
        } catch (NumberFormatException e) {
            throw state.error("Invalid number: " + numStr);
        }
    }

    private ONode parseKeyword(String expect, Object value) throws IOException {
        // ‰ºòÂåñÔºöÊâπÈáèÊØîËæÉ
        int expectLength = expect.length();

        // Á°Æ‰øùÁºìÂÜ≤Âå∫ÊúâË∂≥Â§üÊï∞ÊçÆ
        if (state.bufferPosition + expectLength > state.bufferLimit) {
            if (!state.fillBuffer()) {
                throw state.error("Unexpected end of input in keyword");
            }
        }

        // ÊâπÈáèÊØîËæÉ
        for (int i = 0; i < expectLength; i++) {
            if (state.buffer[state.bufferPosition + i] != expect.charAt(i)) {
                throw state.error("Unexpected keyword: expected '" + expect + "'");
            }
        }

        // ‰∏ÄÊ¨°ÊÄßÂâçËøõ‰ΩçÁΩÆ
        state.bufferPosition += expectLength;
        return new ONode(opts, value);
    }

    private boolean isDigit(char c) {
        return c >= '0' && c <= '9';
    }

    static class ParserState {
        private static final int BUFFER_SIZE = 8192;
        private final Reader reader;
        private long line = 1;
        private long column = 0;

        private final char[] buffer = new char[BUFFER_SIZE];
        private int bufferPosition;
        private int bufferLimit;

        public ParserState(Reader reader) {
            this.reader = reader;
        }

        private char nextChar() throws IOException {
            if (bufferPosition >= bufferLimit && !fillBuffer()) {
                throw error("Unexpected end of input");
            }
            char c = buffer[bufferPosition++];

            // ÈõÜ‰∏≠Â§ÑÁêÜË°å/ÂàóËÆ°Êï∞
            if (c == '\n') {
                line++;
                column = 0;
            } else if (c == '\r') {
                // Ê£ÄÊü• Windows Êç¢Ë°åÁ¨¶ \r\n
                if (peekChar() == '\n') {
                    bufferPosition++; // Ë∑≥Ëøá‰∏ã‰∏Ä‰∏™ \n
                }
                line++;
                column = 0;
            } else {
                column++;
            }

            return c;
        }

        private char peekChar() throws IOException {
            return peekChar(0);
        }

        private char peekChar(int offset) throws IOException {
            if (bufferPosition + offset >= bufferLimit && !fillBuffer()) {
                return 0;
            }
            return (bufferPosition + offset < bufferLimit) ? buffer[bufferPosition + offset] : 0;
        }

        private boolean fillBuffer() throws IOException {
            if (bufferPosition < bufferLimit) return true;
            bufferLimit = reader.read(buffer);
            bufferPosition = 0;
            return bufferLimit > 0;
        }

        private void expect(char expected) throws IOException {
            char c = nextChar();
            if (c != expected) {
                throw error("Expected '" + expected + "' but found '" + c + "'");
            }
        }

        private JsonParseException error(String message) {
            return new JsonParseException(message + " at line " + line + " column " + column);
        }

        private void skipWhitespace() throws IOException {
            while (true) {
                if (bufferPosition >= bufferLimit && !fillBuffer()) {
                    return; // Êñá‰ª∂ÁªìÊùü
                }

                char c = buffer[bufferPosition];
                if ((c == ' ' || c == '\t' || c == '\n' || c == '\r')) {
                    nextChar(); // ‰ΩøÁî® nextChar() Á°Æ‰øùË°å/ÂàóËÆ°Êï∞Ê≠£Á°Æ
                } else {
                    break;
                }
            }
        }

        private void skipComments() throws IOException {
            char c = peekChar();
            if (c == '/') {
                bufferPosition++;
                char next = peekChar();
                if (next == '/') {
                    skipLineComment();
                } else if (next == '*') {
                    skipBlockComment();
                }
            }
        }

        private void skipLineComment() throws IOException {
            while (true) {
                if (bufferPosition >= bufferLimit && !fillBuffer()) break;
                char c = buffer[bufferPosition];
                if (c == '\n') {
                    line++;
                    column = 0;
                    bufferPosition++;
                    break;
                }
                bufferPosition++;
                column++;
            }
        }

        private void skipBlockComment() throws IOException {
            bufferPosition++; // Ë∑≥ËøáËµ∑ÂßãÁöÑ '/'
            boolean closed = false;
            while (true) {
                if (bufferPosition >= bufferLimit && !fillBuffer()) {
                    break;
                }
                char c = buffer[bufferPosition++];
                if (c == '\n') {
                    line++;
                    column = 0;
                } else if (c == '\r') {
                    if (peekChar() == '\n') bufferPosition++;
                    line++;
                    column = 0;
                } else {
                    column++;
                }

                if (c == '*' && peekChar() == '/') {
                    bufferPosition++;
                    closed = true;
                    break;
                }
            }
            if (!closed) {
                throw error("Unclosed block comment");
            }
        }
    }
}